<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"> 
	<head> 
		<title>Pippijn - Programming / C / Inheritance</title> 
		<meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/> 
		<meta http-equiv="content-style-type" content="text/css"/> 
		<meta name="description" content="Pippijn van Steenhoven - Programming / C / Inheritance"/> 
		<link rel="stylesheet" href="/~pippijn/static/css/home.css" type="text/css" title="Clean Blue" media="screen"/> 
		<link rel="icon" type="image/x-icon" href="/~pippijn/static/favicon.ico"/>
	</head> 

	<body> 
		<div id="header"> 
			<h1>Pippijn van Steenhoven</h1> 
			<p id="slogan">I doubt, therefore I might be</p> 
		</div> 

		<div id="sidebar"> 
			<h2>Menu</h2> 
			<div id="menubar">
				<ul>
<li>
<a href="/~pippijn/home/index">Home</a></li><li>
<a href="/~pippijn/home/projects">Projects <span class="small">[+]</span></a></li><li>
<a href="/~pippijn/home/programming">Programming <span class="small">[-]</span></a><ul>
<li>
<a href="/~pippijn/home/programming/data-hiding">Data hiding</a></li><li>
<a href="/~pippijn/home/programming/c">C <span class="small">[-]</span></a><ul>
<li>
<a href="/~pippijn/home/programming/c/strings">Strings</a></li></ul></li><li>
<a href="/~pippijn/home/programming/cpp">C++ <span class="small">[+]</span></a></li></ul></li><li>
<a href="/~pippijn/home/links">Links</a></li><li>
<a href="/~pippijn/home/contact">Contact</a></li></ul>
			</div> 
		</div> 

		<div id="content">
			<h2>
Inheritance</h2>
<ul><li><a href='#h1'>Single inheritance</a></li>
<li><a href='#h2'>Polymorphic data structures</a></li>
<li><a href='#h3'>Links</a></li></ul><p>
Languages such as Java, C# and C++ have object oriented features such as
classes, inheritance, runtime type information and virtual function calls. I
often hear that it's impossible to write object oriented code in a language
that does not directly support it. Most notably, people seem to think this of
C. I am going to show that it is entirely possible, even convenient and
entirely feasible to write object oriented C.</p>
<h3>
<a id='h1'>Single inheritance</a></h3>
<p>
Single inheritance means the derived class earns all data and function members
from its base class. There are several ways to achieve this in C. The most
common method is not the most transparent one, but it is probably the most
consistent and maintainable one.</p>
<h4>
Child objects (has-a)</h4>
<p>
Modelling is-a relationships with has-a is the easiest way to simulate
inheritance. All you need to take care of is accessing the right values in
those included objects. In C++, one can implicitly convert pointers to derived
classes to pointers to their base. One can construct a new object of base type
from an object of derived type (often called slicing, because only the base
part of the object is retained). In C, this implicit construction is not
possible. Consider the following C++ code:</p>
<pre class="code-block">  <span class="comment">// C++ code:</span>
  <span class="key3">struct</span> base {
    <span class="key3">char</span> a;
    <span class="key3">int</span> b;
  };

  <span class="key3">struct</span> derived : base {
    <span class="key3">int</span> c;
    <span class="key3">char</span> d;
  };

  <span class="key3">void</span> function () {
    derived d;
    base b = d;
    base *bp = &amp;d;
    bp-&gt;b = d.a; <span class="comment">// &lt;- either</span>
    bp-&gt;b = d.base::a; <span class="comment">// &lt;- or</span>
  }

</pre><p>
In this code, an object of type <span class='code'>derived</span> is created, then an object of type
<span class='code'>base</span> is created and the derived object is sliced to form the base object.
The address of <span class='code'>d</span> is then implicitly converted to <span class='code'>base *</span> to form the
pointer <span class='code'>bp</span>. The last two lines are equivalent in that they both access the
member <span class='code'>a</span> in the base class and assign it to <span class='code'>b</span> in the base class using
the base pointer.</p>
<pre class="code-block">  <span class="comment">// C code:</span>
  <span class="key3">struct</span> base {
    <span class="key3">char</span> a;
    <span class="key3">int</span> b;
  };

  <span class="key3">struct</span> derived {
    <span class="key3">struct</span> base base;
    <span class="key3">int</span> c;
    <span class="key3">char</span> d;
  };

  <span class="key3">void</span> function () {
    <span class="key3">struct</span> derived d;
    <span class="key3">struct</span> base b = d.base; <span class="comment">// &lt;- either (bad for long inheritance lines)</span>
    <span class="key3">struct</span> base b2 = *(<span class="key3">struct</span> base *)&amp;d; <span class="comment">// &lt;- or</span>
    <span class="key3">struct</span> base *bp = (<span class="key3">struct</span> base *)&amp;d;
    bp-&gt;b = d.base.a; <span class="comment">// &lt;- either (bad)</span>
    bp-&gt;b = ((<span class="key3">struct</span> base *)&amp;d)-&gt;a; <span class="comment">// &lt;- or</span>
  }

</pre><p>
In long lines with several levels of inheritance, base accesses become
cumbersome and casting is probably the way to go. (Think of
<span class='code'>d-&gt;base.base.base.base.base.base.a = 3</span> versus
<span class='code'>((struct somebase *)d)-&gt;a = 3</span>.</p>
<h4>
#include members (is-a)</h4>
<p>
A more transparent way to simulate the above is to use the preprocessor
directive <span class='code'>#include</span> to inherit the base members. The advantage of this is
that member accesses are completely transparent, the disadvantage is that the
data members are going to be spread over many small files.</p>
<pre class="code-block">  <span class="comment">// base-members.h</span>
    <span class="key3">char</span> a;
    <span class="key3">int</span> b;

  <span class="comment">// base.h</span>
  <span class="key3">struct</span> base {
  #<span class="key2">include</span> <span class="string">"base-members.h"</span>
  };

  <span class="comment">// derived-members.h</span>
  #<span class="key2">include</span> <span class="string">"base-members.h"</span>
    <span class="key3">int</span> c;
    <span class="key3">char</span> d;

  <span class="comment">// derived.h</span>
  <span class="key3">struct</span> derived {
  #<span class="key2">include</span> <span class="string">"derived-members.h"</span>
  };

  <span class="comment">// main.c</span>
  <span class="key3">void</span> function () {
    <span class="key3">struct</span> derived d;
    <span class="key3">struct</span> base b = *(<span class="key3">struct</span> base *)&amp;d;
    <span class="key3">struct</span> base *bp = (<span class="key3">struct</span> base *)&amp;d;
    bp-&gt;b = d.a; <span class="comment">// &lt;- works fine for long inheritance lines</span>
  }

</pre><p>
As you can see, the client code for this is cleaner. There is no visible base
object. The casts are all valid, because the beginning of both structs are
equal. This way, you can easily extend to arbitrary inheritance levels. Data
members are simply inherited and casting derived pointers to base pointers is
perfectly valid.</p>
<h3>
<a id='h2'>Polymorphic data structures</a></h3>
<p>
When writing a programming language compiler, you will likely need an abstract
syntax tree (AST). Without such a thing, it is hard to impossible to implement
things such as C++ templates, where you need to copy an entire subtree,
replace template parameters with their arguments and resume typechecking. So,
you need an AST. Such trees are usually directed acyclic graphs consisting of
many nodes of different types pointing at other nodes in the graph. A simple
example could be:</p>
<pre class="code-block">  <span class="key3">struct</span> node {
  };

  <span class="key3">enum</span> op { ADD, SUB, MUL, DIV };

  <span class="comment">// a OP b</span>
  <span class="key3">struct</span> operation : node {
    node *lhs; <span class="comment">// a</span>
    <span class="key3">enum</span> op op; <span class="comment">// +, -, *, /</span>
    node *rhs; <span class="comment">// b</span>
  };

  <span class="key3">struct</span> integer : node {
    <span class="key3">int</span> value;
  };

</pre><p>
Now you can build an expression tree from an expression like <span class='code'>3 + 2 * 7 / 3</span>.
If you want to evaluate the tree, you need to somehow find out what type of
node it is that was on the left or right hand side of the operation. It could
be another operation or an integer. C++ gives us a convenient tool that makes
the evaluation almost entirely transparent [1]. By using runtime type
information, C++ can identify the actual type that was chosen to create the
object, rather than the type of the pointer that is currently pointing at it.</p>
<p>
TODO: you do it with tags.</p>
<h3>
<a id='h3'>Links</a></h3>
<ul>
<li>
[1] <a href='http://en.wikipedia.org/wiki/Visitor_pattern'>Visitor pattern</a></li>
</ul>

		</div> 

		<div id="footer"> 
			<div id="copyright"><a href="/~pippijn/home/contact">Copyright &copy; 2007-2011 Pippijn van Steenhoven</a></div> 
			<div id="updated">Last updated Thu May 26 20:36:24 MEST 2011</div> 
		</div> 
	</body> 
</html> 

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"> 
	<head> 
		<title>Pippijn - Opinions / Negative / Cpp</title> 
		<meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/> 
		<meta http-equiv="content-style-type" content="text/css"/> 
		<meta name="description" content="Pippijn van Steenhoven - Opinions / Negative / Cpp"/> 
		<link rel="stylesheet" href="/home/css/home.css" type="text/css" title="Clean Blue" media="screen"/> 
		<link rel="icon" type="image/x-icon" href="/home/favicon.ico"/>
	</head> 

	<body> 
		<div id="header"> 
			<h1>Pippijn van Steenhoven</h1> 
			<p id="slogan">I doubt, therefore I might be</p> 
		</div> 

		<div id="sidebar"> 
			<h2>Menu</h2> 
			<div id="menubar">
				<ul>
<li>
<a href="/home/">Home</a></li><li>
<a href="/home/projects">Projects <span class="small">[+]</span></a></li><li>
<a href="/home/opinions">Opinions <span class="small">[-]</span></a><ul>
<li>
<a href="/home/opinions/buildsys">Build systems</a></li></ul></li><li>
<a href="/home/programming">Programming <span class="small">[+]</span></a></li><li>
<a href="/home/links">Links</a></li><li>
<a href="/home/contact">Contact</a></li></ul>
			</div> 
		</div> 

		<div id="content">
			<h2>Why not to use C++

</h2> <p>C++ is a powerful object oriented and usually compiled language with a large set
of features. This large set is hard to understand and you need to understand
most of it to be able to use even a subset of it.

</p> <ul>
  <li>No defined ABI (@abi)
  
  
    <p>This is a huge issue with C++. It is rarely possible to compile code with one
    compiler and use the linked machine code library with another. Even compiler
    versions make different ABIs. GCC broke its ABI between 2.9x and 3.x. The GCC
    name mangling is completely different from Microsoft's compiler. Name mangling
    is not the only issue with Application Binary Interfaces. Different exception
    handling mechanisms, different ways of storing member function pointers,
    different virtual call tables, different class layout of polymorphic types and
    more.
    
    </p>
  </li>
  <li>Low performance memory allocation (@malloc)
  
  
    <p>By default, new allocations in C++ need operating system calls. Usually, the
    memory allocator (
      <code>malloc</code> and 
      <code>operator new</code>) do memory pooling and
    subsequently speed up allocations that occur after deallocations of larger size.
    Another commonly used way to speed up allocations is using slice or slab
    allocation. The Microsoft CLR and OCaml have comparatively very fast allocators.
    
    
    </p>
    <p class="small">
      <p>Note that this is not strictly related to C++, rather to specific C++ compilers
      and runtimes. There are runtime libraries that have very fast allocators and
      the new C++ standard is heading towards traceable pointers that could support a
      bump allocator providing allocation speeds near that of the system stack.
      
      </p>
    </p>
  </li>
  <li>Everything has to be done manually (@manual)
  
  
    <p>C++ as a language can't do much. Pointers have no idea how large the memory
    chunk is they point at. As soon as arrays decay into pointers, there is no way
    of knowing how many elements the array can hold. If you want your pointers to
    know the size of their memory block, you have to implement memory management
    yourself and store the block size before the returned memory chunk. This is what
    
      <code>malloc(3)</code> already does in most cases, so it would be redundant.
    
    
    </p>
  </li>
  <li>Unable to modify compiled code (@modify)
  
  
    <p>In C++, it is not possible to modify the compiled code at runtime. In standard
    C++, it is not even possible to generate machine code and execute that at
    runtime.
    
    </p>
  </li>
  <li>Template metaprogramming is complicated (@templates)
  
  
    <p>Templates are a different language with a different syntax than the rest of C++.
    The verbose and different syntax make template metaprogramming cumbersome.  If
    you want, for example, compile-time evaluation of a simple function such as
    fibonacci, you have to write code like this:
    
    </p>
    <code />
    <p>In languages such as Lisp and D, which have compile-time code execution built
    in, writing such an expression is equal to writing normal code:
    
    </p>
    <code />
    <p>The macro is expanded at compile-time. The D programming language has static
    evaluation of complex constant functions. The new C++ standard allows for these,
    but in a severely limited form.
    
    </p>
  </li>
  <li>Compiler diagnostics are often unreadable (@diag)
  
  
    <code />
    <p>The error here is that I was trying to convert a 
      <code>node_base</code> pointer to a
    derived 
      <code>node</code> pointer without a cast.
    
    
    </p>
  </li>
  <li>Bad support for data hiding (@datahiding)
  
  
    <p>The C++ programming language requires you to provide the complete class
    description, including private members, in the interface file. In C, you can
    pass around opaque pointers to an object, in Java you don't even need the source
    file in order to use a class. The 
      <code>private</code> modifier in C++ is mostly used as
    documentation, saying "you should not modify this yourself". If you really want
    to, you can still do it:
    
    
    </p>
    <code />
    <p>Now we can just define the exact same class but with the 
      <code>public</code> keyword moved
    up two lines, get rid of the 
      <code>const</code> keyword and use 
      <code>reinterpret_cast</code> to
    cast the object to our own class and happily modify x and y even though they
    were private and constant. If we felt hacky, we could 
      <code>#define private public</code>
    in this case. That, however, does not work if 
      <code>private</code> is omitted. Of course,
    all of this violates the C++ standard, but safe languages such as Java (and
    OCaml without the Obj interface) don't even provide you with the ability to
    violate it.
    
    
    </p>
    <p>In C++, a workaround for this exists and it is called the
    
      <a href="http://en.wikipedia.org/wiki/Opaque_pointer#C.2B.2B">pimpl idiom</a>.
    
    
    </p>
  </li>
  <li>Undefined behaviour (@ub)
  
  
    <p>C++ has a set of lowlevel features such as pointer arithmetics and memory
    functions (
      <code>memcpy</code> and friends). With these features, it is very easy to
    induce undefined behaviour. Some examples of undefined behaviour are:
    
    
    </p>
    <ul>
      <li>Dereferencing a 
        <code>NULL</code>-pointer
      
      
      </li>
      <li>Accessing an out-of-range element in an 
        <code>std::vector</code>
      
      
      </li>
      <li>Modifying a value twice between two sequence points
      
      
        <p>An example for this would be the famous 
          <code>p++ + ++p</code>. This does not strictly
        fall under undefined behaviour but rather under unspecified behaviour.
        
        
        </p>
      </li>
      <li>Using an invalid pointer
      
      
        <p>An example for an invalid pointer is a pointer whose pointee has been destroyed
        already. Using such a pointer includes assigning it to another pointer and
        passing it to functions.
        
        </p>
      </li>
      <li>Using the 
        <code>delete</code> keyword on pointers of incomplete type when the type has a nontrivial destructor.
      
      
      </li>
      <li>Casting negative values to an unsigned integral type
      
      </li>
      <li>Modifying a 
        <code>const</code>-qualified value by means of 
        <code>const_cast</code>
      
      
      </li>
      <li>Calling a function with arguments that are function calls
      
      
        <p>It is not defined in which order 
          <code>g</code> and 
          <code>h</code> are called in 
          <code>f(g(), h())</code>.
        
        
        </p>
      </li>
    </ul>
    <p>This is just a short list of actions leading to undefined or unspecified
    behaviour. ISO/IEC 14882:1998 documents more than 100 of these. If a programmer
    is insufficiently skilled, these actions may cause serious astonishment.
    Astonishment is something Java tries to avoid by following the "Principle of
    Least Astonishment".
    
    </p>
  </li>
  <li>In production, only usable with skilled programmers (@skills)
  
  
    <p>Languages such as Java also allow mediumly skilled programmers to join a
    development team. C++ programmers, in contrast, require a high level of
    proficiency in the language in order to write usable code. Skills required for
    writing good C++ code include:
    
    </p>
    <ul>
      <li>Good understanding of object-orientation
      
      
        <p>Without such knowledge, you can end up writing procedural code that has nothing
        to do with object oriented design. On a related note, the fact that C++ allows
        its member functions to be non-virtual (in other words: not to be overridden)
        but does not prevent subclasses from actually overriding them results in errors
        that may be hard to trace.
        
        </p>
      </li>
      <li>Knowledge of memory layout
      
      
        <p>Memory management in C++ has to be done manually. It is possible to use a
        garbage collector using libraries supplying such, but it is also possible and
        even easy to trick such a library (for example by casting the pointers to
        integers, 
          <code>XOR</code>ing them with a value, storing them somewhere and 
          <code>XOR</code>ing them
        back to the original value, casting them back to pointers and expecting them to
        be valid). Memory leaks can be prevented by using reference counting smart
        pointers but those suffer from the common reference counting issues such as
        circular references. In this case, weak references help.
        
        
        </p>
      </li>
    </ul>
    <p>You are allowed to return a reference or pointer to a stack-allocated object.
    You are allowed to overflow memory buffers. You are allowed to access out of
    range indices. All of that makes the language a dangerous tool. As a Java
    programmer once told me: "C++ is useful only for cases where your programmers
    ALL KICK ASS".
    
    </p>
  </li>
  <li>Verbose "lambda expression" (@verbose)
  
  
    <p>In order to emulate lambda expressions in C++, you have to write verbose code
    like this:
    
    </p>
    <code />
    <p>In Java, this code becomes a little less verbose, if the Collection was sorted:
    
    </p>
    <code />
    <p>Or, in languages with functional elements such as Perl:
    
    </p>
    <code />
  </li>
  <li>Operator overloading can make code complicated (@overload)
  
  
    <p>In C++, almost every operator can be overloaded. This includes 
      <code>operator||</code> and
    
      <code>operator,</code>. Overloading them can lead to confusion. There are a few rules of
    "good practice". As such, overloading a comparison operator to have side-effects
    is bad practice. Overloading the sequential evaluation operator is bad practice.
    Overloading 
      <code>operator&amp;&amp;</code> and 
      <code>operator||</code> are bad practice. Compilers
    will unlikely warn about it, though.
    
    
    </p>
  </li>
  <li>Very idiomatic (@idiom)
  
  
    <p>Writing solid C++ code requires mastery of almost the whole language and many of
    its idioms.
    
    </p>
  </li>
  <li>Complex grammar (@grammar)
  
  
    <p>C++ can not be expressed in an LR(1) grammar. It is context-dependent and as
    such requires considerable effort from both the machine parser and the human eye
    to be understood.
    
    </p>
  </li>
  <li>Impossible to chain constructors (@chained_ctor)
  
  
    <p>Where in Java one could write
    
    </p>
    <code />
    <p>this is not possible at all in C++. One can not chain constructors (this has
    been fixed in C++11). Trying it like this:
    
    </p>
    <code />
    <p>does call the other constructor but creates an anonymous 
      <code>Point</code> on the stack
    and discards it right away. Trying to copy the Java syntax 
      <code>this()</code> results in
    a compile-time error.
    
    
    </p>
  </li>
</ul>
		</div> 

		<div id="footer"> 
			<div id="copyright"><a href="/home/contact">Copyright &copy; 2007-2013 Pippijn van Steenhoven</a></div> 
			<div id="updated">Last updated Mon Aug 12 02:39:07 MEST 2013</div> 
		</div> 
	</body> 
</html> 

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"> 
	<head> 
		<title>Pippijn - Opinions / Negative / Cpp</title> 
		<meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/> 
		<meta http-equiv="content-style-type" content="text/css"/> 
		<meta name="description" content="Pippijn van Steenhoven - Opinions / Negative / Cpp"/> 
		<link rel="stylesheet" href="/home/css/home.css" type="text/css" title="Clean Blue" media="screen"/> 
		<link rel="icon" type="image/x-icon" href="/home/favicon.ico"/>
	</head> 

	<body> 
		<div id="header"> 
			<h1>Pippijn van Steenhoven</h1> 
			<p id="slogan">I doubt, therefore I might be</p> 
		</div> 

		<div id="sidebar"> 
			<h2>Menu</h2> 
			<div id="menubar">
				<ul>
<li>
<a href="/home/">Home</a></li><li>
<a href="/home/projects">Projects <span class="small">[+]</span></a></li><li>
<a href="/home/opinions">Opinions <span class="small">[-]</span></a><ul>
<li>
<a href="/home/opinions/buildsys">Build systems</a></li></ul></li><li>
<a href="/home/programming">Programming <span class="small">[+]</span></a></li><li>
<a href="/home/links">Links</a></li><li>
<a href="/home/contact">Contact</a></li></ul>
			</div> 
		</div> 

		<div id="content">
			<h2>
Why not to use C++</h2>
<ul></ul><p>
C++ is a powerful object oriented and usually compiled language with a large set
of features. This large set is hard to understand and you need to understand
most of it to be able to use even a subset of it.</p>
<ul>
<li>
No defined ABI<a id='abi'></a><p>
This is a huge issue with C++. It is rarely possible to compile code with one
compiler and use the linked machine code library with another. Even compiler
versions make different ABIs. GCC broke its ABI between 2.9x and 3.x. The GCC
name mangling is completely different from Microsoft's compiler. Name mangling
is not the only issue with Application Binary Interfaces. Different exception
handling mechanisms, different ways of storing member function pointers,
different virtual call tables, different class layout of polymorphic types and
more.</p>
</li>
<li>
Low performance memory allocation<a id='malloc'></a><p>
By default, new allocations in C++ need operating system calls. Usually, the
memory allocator (<span class='code'>malloc</span> and <span class='code'>operator new</span>) do memory pooling and
subsequently speed up allocations that occur after deallocations of larger size.
Another commonly used way to speed up allocations is using slice or slab
allocation. The Microsoft CLR and OCaml have comparatively very fast allocators.</p>
<p class='small'>Note that this is not strictly related to C++, rather to specific C++ compilers
and runtimes. There are runtime libraries that have very fast allocators and
the new C++ standard is heading towards traceable pointers that could support a
bump allocator providing allocation speeds near that of the system stack.

</p></li>
<li>
Everything has to be done manually<a id='manual'></a><p>
C++ as a language can't do much. Pointers have no idea how large the memory
chunk is they point at. As soon as arrays decay into pointers, there is no way
of knowing how many elements the array can hold. If you want your pointers to
know the size of their memory block, you have to implement memory management
yourself and store the block size before the returned memory chunk. This is what
<span class='code'>malloc(3)</span> already does in most cases, so it would be redundant.</p>
</li>
<li>
Unable to modify compiled code<a id='modify'></a><p>
In C++, it is not possible to modify the compiled code at runtime. In standard
C++, it is not even possible to generate machine code and execute that at
runtime.</p>
</li>
<li>
Template metaprogramming is complicated<a id='templates'></a><p>
Templates are a different language with a different syntax than the rest of C++.
The verbose and different syntax make template metaprogramming cumbersome.  If
you want, for example, compile-time evaluation of a simple function such as
fibonacci, you have to write code like this:</p>
<pre class="code-block">   <span class="comment">// Define generic fibonacci algorithm</span>
   <span class="key3">template</span>&lt;<span class="key3">int</span> N&gt;
   <span class="key3">struct</span> fibonacci
   {
     <span class="key3">static</span> <span class="key3">int</span> <span class="key3">const</span> value = fibonacci&lt;N - <span class="number">1</span>&gt;::value + fibonacci&lt;N - <span class="number">2</span>&gt;::value;
   }
   <span class="comment">// Specialise it for N == 0</span>
   <span class="key3">template</span>&lt;&gt;
   <span class="key3">struct</span> fibonacci&lt;<span class="number">0</span>&gt;
   {
     <span class="key3">static</span> <span class="key3">int</span> <span class="key3">const</span> value = <span class="number">1</span>;
   }
   <span class="comment">// Specialise it for N == 1</span>
   <span class="key3">template</span>&lt;&gt;
   <span class="key3">struct</span> fibonacci&lt;<span class="number">1</span>&gt;
   {
     <span class="key3">static</span> <span class="key3">int</span> <span class="key3">const</span> value = <span class="number">1</span>;
   }
   <span class="comment">// USe it like this:</span>
   <span class="key3">static</span> <span class="key3">int</span> <span class="key3">const</span> fib4 = fibonacci&lt;<span class="number">4</span>&gt;::value;

</pre><p>
In languages such as Lisp and D, which have compile-time code execution built
in, writing such an expression is equal to writing normal code:</p>
<pre class="code-block">   <span class="comment">; Macro to calculate fibonacci numbers</span>
   (<span class="key1">defmacro</span> fib (n)
     (<span class="key1">labels</span> ((fib (n)
                (<span class="key1">if</span> (<span class="key1">&lt;=</span> n <span class="number">1</span>)
                  n
                  (<span class="key1">+</span> (fib (<span class="key1">-</span> n <span class="number">1</span>)) (fib (<span class="key1">-</span> n <span class="number">2</span>))))))
       (fib n)))
   <span class="comment">; Use it like this:</span>
   (<span class="key1">print</span> (fib <span class="number">4</span>))

</pre><p>
The macro is expanded at compile-time. The D programming language has static
evaluation of complex constant functions. The new C++ standard allows for these,
but in a severely limited form.</p>
</li>
<li>
Compiler diagnostics are often unreadable<a id='diag'></a><pre class="code-block">   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h: In member function ‘adt::detail::hash_table_impl&lt;TraitsT&gt;
   ::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::node::next() [with TraitsT = adt::detail::choose_traits&lt;DEFAULT, std::pa
   ir, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;<span class="key3">int</span>, <span class="key3">int</span>&gt;]’:
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">647</span>:   instantiated from ‘adt::detail::hash_table_impl&lt;Tra
   itsT&gt;::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::create_node_uniq(<span class="key3">const</span> <span class="key3">typename</span> TraitsT::pair_type&amp;, <span class="key3">bool</span>&amp;) [with T
   raitsT = adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt:
   :hash_policy&gt;::type&gt;::type&lt;<span class="key3">int</span>, <span class="key3">int</span>&gt;]’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">1248</span>:   instantiated from ‘typename adt::detail::choose_tr
   aits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type&lt;KeyT, ValueT&gt;::value_type&amp; adt::hash_table&lt;KeyT, ValueT, Policy, PairT,
    FullTraitsT, TraitsT&gt;::<span class="key1">operator</span>[](<span class="key3">const</span> <span class="key3">typename</span> adt::detail::choose_traits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type
   &lt;KeyT, ValueT&gt;::key_type&amp;) [with KeyT = <span class="key3">int</span>, ValueT = <span class="key3">int</span>, adt::rp::resize_policy Policy = DEFAULT, PairT = std::pair, 
   FullTraitsT = adt::hash_policy, TraitsT = adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type]’
   /home/pippijn/rona/devel/librona/run.cc:<span class="number">20</span>:   instantiated from here
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">251</span>: <span class="key2">error</span>: invalid conversion from ‘adt::detail::node_bas
   e*’ to ‘adt::detail::hash_table_impl&lt;adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill
   _in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;<span class="key3">int</span>, <span class="key3">int</span>&gt; &gt;::node*’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h: In member function ‘adt::detail::hash_table_impl&lt;TraitsT&gt;
   ::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::node::next() [with TraitsT = adt::detail::choose_traits&lt;DEFAULT, std::pa
   ir, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;<span class="key3">long</span> <span class="key3">int</span>, <span class="key3">long</span> <span class="key3">int</span>&gt;]’:
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">647</span>:   instantiated from ‘adt::detail::hash_table_impl&lt;Tra
   itsT&gt;::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::create_node_uniq(<span class="key3">const</span> <span class="key3">typename</span> TraitsT::pair_type&amp;, <span class="key3">bool</span>&amp;) [with T
   raitsT = adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt:
   :hash_policy&gt;::type&gt;::type&lt;<span class="key3">long</span> <span class="key3">int</span>, <span class="key3">long</span> <span class="key3">int</span>&gt;]’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">1248</span>:   instantiated from ‘typename adt::detail::choose_tr
   aits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type&lt;KeyT, ValueT&gt;::value_type&amp; adt::hash_table&lt;KeyT, ValueT, Policy, PairT,
    FullTraitsT, TraitsT&gt;::<span class="key1">operator</span>[](<span class="key3">const</span> <span class="key3">typename</span> adt::detail::choose_traits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type
   &lt;KeyT, ValueT&gt;::key_type&amp;) [with KeyT = <span class="key3">long</span> <span class="key3">int</span>, ValueT = <span class="key3">long</span> <span class="key3">int</span>, adt::rp::resize_policy Policy = DEFAULT, PairT = s
   td::pair, FullTraitsT = adt::hash_policy, TraitsT = adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type]’
   /home/pippijn/rona/devel/librona/run.cc:<span class="number">127</span>:   instantiated from here
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">251</span>: <span class="key2">error</span>: invalid conversion from ‘adt::detail::node_bas
   e*’ to ‘adt::detail::hash_table_impl&lt;adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill
   _in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;<span class="key3">long</span> <span class="key3">int</span>, <span class="key3">long</span> <span class="key3">int</span>&gt; &gt;::node*’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h: In member function ‘adt::detail::hash_table_impl&lt;TraitsT&gt;
   ::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::node::next() [with TraitsT = adt::detail::choose_traits&lt;DEFAULT, std::pa
   ir, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;adt::scalar, adt::scalar&gt;
   ]’:
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">647</span>:   instantiated from ‘adt::detail::hash_table_impl&lt;Tra
   itsT&gt;::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::create_node_uniq(<span class="key3">const</span> <span class="key3">typename</span> TraitsT::pair_type&amp;, <span class="key3">bool</span>&amp;) [with T
   raitsT = adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt:
   :hash_policy&gt;::type&gt;::type&lt;adt::scalar, adt::scalar&gt;]’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">1248</span>:   instantiated from ‘typename adt::detail::choose_tr
   aits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type&lt;KeyT, ValueT&gt;::value_type&amp; adt::hash_table&lt;KeyT, ValueT, Policy, PairT,
    FullTraitsT, TraitsT&gt;::<span class="key1">operator</span>[](<span class="key3">const</span> <span class="key3">typename</span> adt::detail::choose_traits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type
   &lt;KeyT, ValueT&gt;::key_type&amp;) [with KeyT = adt::scalar, ValueT = adt::scalar, adt::rp::resize_policy Policy = DEFAULT, Pai
   rT = std::pair, FullTraitsT = adt::hash_policy, TraitsT = adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::t
   ype]’
   /home/pippijn/rona/devel/librona/run.cc:<span class="number">130</span>:   instantiated from here
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">251</span>: <span class="key2">error</span>: invalid conversion from ‘adt::detail::node_bas
   e*’ to ‘adt::detail::hash_table_impl&lt;adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill
   _in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;adt::scalar, adt::scalar&gt; &gt;::node*’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h: In member function ‘adt::detail::hash_table_impl&lt;TraitsT&gt;
   ::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::node::next() [with TraitsT = adt::detail::choose_traits&lt;DEFAULT, std::pa
   ir, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;std::basic_string&lt;<span class="key3">char</span>, s
   td::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt;, std::basic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt; &gt;
   ]’:
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">647</span>:   instantiated from ‘adt::detail::hash_table_impl&lt;Tra
   itsT&gt;::node* adt::detail::hash_table_impl&lt;TraitsT&gt;::create_node_uniq(<span class="key3">const</span> <span class="key3">typename</span> TraitsT::pair_type&amp;, <span class="key3">bool</span>&amp;) [with T
   raitsT = adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill_in&lt;DEFAULT, std::pair, adt:
   :hash_policy&gt;::type&gt;::type&lt;std::basic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt;, std::basic_string&lt;ch
   ar, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt; &gt;]’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">1310</span>:   instantiated from ‘PairT&lt;<span class="key3">typename</span> adt::detail::has
   h_table_impl&lt;<span class="key3">typename</span> adt::detail::choose_traits&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type&lt;KeyT, ValueT&gt; &gt;::iterator, 
   <span class="key3">bool</span>&gt; adt::hash_table&lt;KeyT, ValueT, Policy, PairT, FullTraitsT, TraitsT&gt;::insert(<span class="key3">const</span> <span class="key3">typename</span> adt::detail::choose_tra
   its&lt;Policy, PairT, FullTraitsT, TraitsT&gt;::type&lt;KeyT, ValueT&gt;::pair_type&amp;) [with KeyT = std::basic_string&lt;<span class="key3">char</span>, std::cha
   r_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt;, ValueT = std::basic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt;
   , adt::rp::resize_policy Policy = DEFAULT, PairT = std::pair, FullTraitsT = adt::hash_policy, TraitsT = adt::detail::fi
   ll_in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type]’
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">1456</span>:   instantiated from ‘void hash_table&lt;KeyT, ValueT&gt;::
   put(KeyT, ValueT) [with KeyT = std::basic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt;, ValueT = std::ba
   sic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt;]’
   /home/pippijn/rona/devel/librona/run.cc:<span class="number">133</span>:   instantiated from here
   /home/pippijn/rona/devel/librona/<span class="key2">include</span>/AD/hash/hashtable.h:<span class="number">251</span>: <span class="key2">error</span>: invalid conversion from ‘adt::detail::node_bas
   e*’ to ‘adt::detail::hash_table_impl&lt;adt::detail::choose_traits&lt;DEFAULT, std::pair, adt::hash_policy, adt::detail::fill
   _in&lt;DEFAULT, std::pair, adt::hash_policy&gt;::type&gt;::type&lt;std::basic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;c
   har&gt; &gt;, std::basic_string&lt;<span class="key3">char</span>, std::char_traits&lt;<span class="key3">char</span>&gt;, std::allocator&lt;<span class="key3">char</span>&gt; &gt; &gt; &gt;::node*’

</pre><p>
The error here is that I was trying to convert a <span class='code'>node_base</span> pointer to a
derived <span class='code'>node</span> pointer without a cast.</p>
</li>
<li>
Bad support for data hiding<a id='datahiding'></a><p>
The C++ programming language requires you to provide the complete class
description, including private members, in the interface file. In C, you can
pass around opaque pointers to an object, in Java you don't even need the source
file in order to use a class. The <span class='code'>private</span> modifier in C++ is mostly used as
documentation, saying "you should not modify this yourself". If you really want
to, you can still do it:</p>
<pre class="code-block">   <span class="comment">// Class with private members</span>
   <span class="key3">class</span> point
   {
   <span class="key1">private</span>:
     <span class="key3">int</span> <span class="key3">const</span> x_;
     <span class="key3">int</span> <span class="key3">const</span> y_;
   <span class="key1">public</span>:
     point (<span class="key3">int</span> x, <span class="key3">int</span> y) : x_ (x), y_ (y) { }
     <span class="key3">int</span> x () { <span class="key1">return</span> x_; }
     <span class="key3">int</span> y () { <span class="key1">return</span> y_; }
   };

</pre><p>
Now we can just define the exact same class but with the <span class='code'>public</span> keyword moved
up two lines, get rid of the <span class='code'>const</span> keyword and use <span class='code'>reinterpret_cast</span> to
cast the object to our own class and happily modify x and y even though they
were private and constant. If we felt hacky, we could <span class='code'>#define private public</span>
in this case. That, however, does not work if <span class='code'>private</span> is omitted. Of course,
all of this violates the C++ standard, but safe languages such as Java (and
OCaml without the Obj interface) don't even provide you with the ability to
violate it.</p>
<p>
In C++, a workaround for this exists and it is called the
<a href='http://en.wikipedia.org/wiki/Opaque_pointer#C.2B.2B'>pimpl idiom</a>.</p>
</li>
<li>
Undefined behaviour<a id='ub'></a><p>
C++ has a set of lowlevel features such as pointer arithmetics and memory
functions (<span class='code'>memcpy</span> and friends). With these features, it is very easy to
induce undefined behaviour. Some examples of undefined behaviour are:</p>
<ul>
<li>
Dereferencing a <span class='code'>NULL</span>-pointer</li>
<li>
Accessing an out-of-range element in an <span class='code'>std::vector</span></li>
<li>
Modifying a value twice between two sequence points<p>
An example for this would be the famous <span class='code'>p++ + ++p</span>. This does not strictly
fall under undefined behaviour but rather under unspecified behaviour.</p>
</li>
<li>
Using an invalid pointer<p>
An example for an invalid pointer is a pointer whose pointee has been destroyed
already. Using such a pointer includes assigning it to another pointer and
passing it to functions.</p>
</li>
<li>
Using the <span class='code'>delete</span> keyword on pointers of incomplete type when the type has a nontrivial destructor.</li>
<li>
Casting negative values to an unsigned integral type</li>
<li>
Modifying a <span class='code'>const</span>-qualified value by means of <span class='code'>const_cast</span></li>
<li>
Calling a function with arguments that are function calls<p>
It is not defined in which order <span class='code'>g</span> and <span class='code'>h</span> are called in <span class='code'>f(g(), h())</span>.</p>
</li>
</ul>
<p>
This is just a short list of actions leading to undefined or unspecified
behaviour. ISO/IEC 14882:1998 documents more than 100 of these. If a programmer
is insufficiently skilled, these actions may cause serious astonishment.
Astonishment is something Java tries to avoid by following the "Principle of
Least Astonishment".</p>
</li>
<li>
In production, only usable with skilled programmers<a id='skills'></a><p>
Languages such as Java also allow mediumly skilled programmers to join a
development team. C++ programmers, in contrast, require a high level of
proficiency in the language in order to write usable code. Skills required for
writing good C++ code include:</p>
<ul>
<li>
Good understanding of object-orientation<p>
Without such knowledge, you can end up writing procedural code that has nothing
to do with object oriented design. On a related note, the fact that C++ allows
its member functions to be non-virtual (in other words: not to be overridden)
but does not prevent subclasses from actually overriding them results in errors
that may be hard to trace.</p>
</li>
<li>
Knowledge of memory layout<p>
Memory management in C++ has to be done manually. It is possible to use a
garbage collector using libraries supplying such, but it is also possible and
even easy to trick such a library (for example by casting the pointers to
integers, <span class='code'>XOR</span>ing them with a value, storing them somewhere and <span class='code'>XOR</span>ing them
back to the original value, casting them back to pointers and expecting them to
be valid). Memory leaks can be prevented by using reference counting smart
pointers but those suffer from the common reference counting issues such as
circular references. In this case, weak references help.</p>
</li>
</ul>
<p>
You are allowed to return a reference or pointer to a stack-allocated object.
You are allowed to overflow memory buffers. You are allowed to access out of
range indices. All of that makes the language a dangerous tool. As a Java
programmer once told me: "C++ is useful only for cases where your programmers
ALL KICK ASS".</p>
</li>
<li>
Verbose "lambda expression"<a id='verbose'></a><p>
In order to emulate lambda expressions in C++, you have to write verbose code
like this:</p>
<pre class="code-block">   <span class="key3">struct</span> equality_predicate
   {
     equality_predicate (<span class="key3">char</span> <span class="key3">const</span> *key) : key_ (key) { }
     <span class="key3">bool</span> <span class="key1">operator</span> () (<span class="key3">char</span> <span class="key3">const</span> *key)
     {
       <span class="key1">return</span> !strcmp (key, key_);
     }
   <span class="key1">private</span>:
     <span class="key3">char</span> <span class="key3">const</span> *key_;
   };
   std::find (c.begin (), c.end (), equality_predicate (key)); <span class="comment">// c is a linear container</span>

</pre><p>
In Java, this code becomes a little less verbose, if the Collection was sorted:</p>
<pre class="code-block">   <span class="key5">Collections</span>.binarySearch(c, key, <span class="key1">new</span> <span class="key5">Comparator</span>&lt;<span class="key5">String</span>&gt;() {
       <span class="key1">public</span> <span class="key3">int</span> compare(<span class="key5">String</span> a, <span class="key5">String</span> b) {
           <span class="key1">return</span> a.compareTo(b);
       }
   });

</pre><p>
Or, in languages with functional elements such as Perl:</p>
<pre class="code-block">   $c-&gt;find ($key, <span class="key1">sub</span> {
      $_[<span class="number">0</span>] <span class="key3">eq</span> $_[<span class="number">1</span>]
   });

</pre></li>
<li>
Operator overloading can make code complicated<a id='overload'></a><p>
In C++, almost every operator can be overloaded. This includes <span class='code'>operator||</span> and
<span class='code'>operator,</span>. Overloading them can lead to confusion. There are a few rules of
"good practice". As such, overloading a comparison operator to have side-effects
is bad practice. Overloading the sequential evaluation operator is bad practice.
Overloading <span class='code'>operator&amp;&amp;</span> and <span class='code'>operator||</span> are bad practice. Compilers
will unlikely warn about it, though.</p>
</li>
<li>
Very idiomatic<a id='idiom'></a><p>
Writing solid C++ code requires mastery of almost the whole language and many of
its idioms.</p>
</li>
<li>
Complex grammar<a id='grammar'></a><p>
C++ can not be expressed in an LR(1) grammar. It is context-dependent and as
such requires considerable effort from both the machine parser and the human eye
to be understood.</p>
</li>
<li>
Impossible to chain constructors<a id='chained_ctor'></a><p>
Where in Java one could write</p>
<pre class="code-block">   <span class="key3">class</span> <span class="key5">Point</span>
   {
       <span class="key3">int</span> x, y;
       <span class="key5">Point</span>(<span class="key3">int</span> x, <span class="key3">int</span> y)
       {
           <span class="key1">this</span>.x = x;
           <span class="key1">this</span>.y = y;
       }
       <span class="key5">Point</span>(<span class="key3">int</span> xAndY)
       {
           <span class="key1">this</span>(xAndY, xAndY);
       }
   }

</pre><p>
this is not possible at all in C++. One can not chain constructors (this has
been fixed in C++11). Trying it like this:</p>
<pre class="code-block">   <span class="key3">class</span> Point
   {
       <span class="key3">int</span> x, y;
       Point (<span class="key3">int</span> x, <span class="key3">int</span> y)
       {
           <span class="key1">this</span>-&gt;x = x;
           <span class="key1">this</span>-&gt;y = y;
       }
       Point (<span class="key3">int</span> xAndY)
       {
           Point (xAndY, xAndY); <span class="comment">// The other constructor is indeed called, but not for 'this'</span>
       }
   };

</pre><p>
does call the other constructor but creates an anonymous <span class='code'>Point</span> on the stack
and discards it right away. Trying to copy the Java syntax <span class='code'>this()</span> results in
a compile-time error.</p>
</li>
</ul>

		</div> 

		<div id="footer"> 
			<div id="copyright"><a href="/home/contact">Copyright &copy; 2007-2013 Pippijn van Steenhoven</a></div> 
			<div id="updated">Last updated Thu Dec  6 23:26:19 CET 2012</div> 
		</div> 
	</body> 
</html> 

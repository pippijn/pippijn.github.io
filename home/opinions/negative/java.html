<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"> 
	<head> 
		<title>Pippijn - Opinions / Negative / Java</title> 
		<meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/> 
		<meta http-equiv="content-style-type" content="text/css"/> 
		<meta name="description" content="Pippijn van Steenhoven - Opinions / Negative / Java"/> 
		<link rel="stylesheet" href="/~pippijn/static/css/home.css" type="text/css" title="Clean Blue" media="screen"/> 
		<link rel="icon" type="image/x-icon" href="/~pippijn/static/favicon.ico"/>
	</head> 

	<body> 
		<div id="header"> 
			<h1>Pippijn van Steenhoven</h1> 
			<p id="slogan">I doubt, therefore I might be</p> 
		</div> 

		<div id="sidebar"> 
			<h2>Menu</h2> 
			<div id="menubar">
				<ul>
<li>
<a href="/~pippijn/home/index">Home</a></li><li>
<a href="/~pippijn/home/projects">Projects <span class="small">[+]</span></a></li><li>
<a href="/~pippijn/home/programming">Programming <span class="small">[+]</span></a></li><li>
<a href="/~pippijn/home/links">Links</a></li><li>
<a href="/~pippijn/home/contact">Contact</a></li></ul>
			</div> 
		</div> 

		<div id="content">
			<h2>
Why not to use Java</h2>
<ul><li><a href='#h1'>Links</a></li></ul><p>
Java is a fast byte-code compiled language with garbage collection and a simple
syntax. Its simplicity, though, leads to many inelegancies, some of which I will
describe here.</p>
<ul>
<li>
No undefined behaviour?<a id='ub'></a><p>
Actually, there is. If you create objects of a class with finalisers that create
objects with finalisers and call <span class='code'>System.runFinalizersOnExit(true)</span> before
exiting, the behaviour is undefined. Will the JVM exit? Will it keep on creating
objects and destroying them right away due to the JVM exiting? The JLS (Java
Language Specification) does not specify this.</p>
</li>
<li>
Overuse of inheritance<a id='inheritance'></a><p>
Due to Java's lack of proper generics or templates, programmers are forced to
use inheritance for everything. Where in C++, one could write</p>
<pre class="code-block">   <span class="key3">template</span>&lt;<span class="key3">typename</span> CollectionT, <span class="key3">typename</span> T&gt;
   <span class="key3">void</span> add_item (CollectionT collection, T element)
   {
     collection.add (element);
   }

</pre><p>
and it would work for all types that provide a member function called <span class='code'>add(T)</span>,
in Java, we have to inherit from <span class='code'>java.util.Collection&lt;T&gt;</span> and write</p>
<pre class="code-block">   <span class="key1">public</span> &lt;T&gt; <span class="key3">void</span> addItem(<span class="key5">Collection</span>&lt;T&gt; collection, T element)
   {
       collection.add(element);
   }

</pre></li>
<li>
No proper generics<a id='generics'></a><p>
Apart from the issue explained in the point above, generics in Java are pretty
useless. The only thing they add to the language is some sort of type-safety.
Type-safety is pretty much overrated, in my opinion, but that's not relevant
now. In the Java runtime, generics do not exist. This simple fact limits their
use enormously. Think about the following simple factory function:</p>
<pre class="code-block">   <span class="key1">public</span> &lt;T&gt; T create() {
       <span class="key1">return</span> <span class="key1">new</span> T();
   }

</pre><p>
This code does not compile, because T can not be instantiated. The reason for
this is explained in 4.6 of the JLS. Types are erased. They do not exist at
runtime. Therefore, it is not possible to create new objects or arrays of them.
The Java solution is to pass in a non-generic factory class that instantiates
the object. What this factory function was supposed to deliver, though, was a
generic factory class. A factory class you can pass in could be Class&lt;T&gt;.
The code could be written like this:</p>
<pre class="code-block">   <span class="key1">public</span> &lt;T&gt; T create(<span class="key5">Class</span>&lt;T&gt; cls) {
       <span class="key1">return</span> cls.newInstance();
   }
   <span class="comment">// Or, for arrays:</span>
   <span class="key1">public</span> &lt;T&gt; T[] createArray(<span class="key5">Class</span>&lt;T[]&gt; arraytype, <span class="key3">int</span> size) {
       <span class="key1">return</span> arraytype.cast(<span class="key5">Array</span>.newInstance(arraytype.getComponentType(), size));
   }

</pre><p>
Note that you can not create arrays of primitive types this way, only of the
boxed versions. Another issue with Java generics is that due to type erasure,
only class or interface types may be used inside a generic. The effect of this
is that collections such as <span class='code'>Vector&lt;Integer&gt;</span> do not hold the integer
values in a contiguous chunk of memory, encouraging fragmentation of memory.o
The <span class='code'>Integer</span>s are allocated in various places on the heap.</p>
<p>
It is also not possible to write code like this:</p>
<pre class="code-block">   <span class="key1">public</span> &lt;T&gt; <span class="key3">void</span> func(T o) {
       o.method();
   }

</pre><p>
While using C++ templates, this would be possible for all types T that define a
member function <span class='code'>method()</span>. In Java, the solution to this is:</p>
<pre class="code-block">   <span class="key1">public</span> &lt;T <span class="key3">extends</span> TypeWithMethod&gt; <span class="key3">void</span> func(T o) {
       o.method();
   }

</pre><p>
This pretty much repeats the point above, but emphasises more on the generics
part of the issue whereas the other point emphasises on the inheritance part.</p>
</li>
<li>
Garbage collection<a id='gc'></a><p>
Garbage collection is often used as the killer argument for modern imperative
languages such as Java and C#. In such languages, programmers tend to think that
they don't need to take care of memory. This is not true. You still need to be
careful with object allocation. For one, it is expensive to create an object. It
involves a call to the <span class='code'>new</span> instruction for allocation and then multiple calls
to virtual methods (the constructor chain). More importantly, though, is the
fact that objects are not reused. Java does not put its locally used objects on
the stack, so this space is not reused. Consider the following code:</p>
<pre class="code-block">   <span class="key1">for</span> (<span class="key5">Collection</span>&lt;Item&gt; c : collections) {
      <span class="key5">Vector</span>&lt;Item&gt; v = <span class="key1">new</span> <span class="key5">Vector</span>&lt;Item&gt;();
      <span class="key1">for</span> (Item i : c) {
         v.add(i);
      }
      doSomething(v);
   }

</pre><p>
In this code, a new <span class='code'>Vector&lt;Item&gt;</span> object is created every time and
discarded for the next outer loop iteration. This code could be rewritten as</p>
<pre class="code-block">   <span class="key5">Vector</span>&lt;Item&gt; v = <span class="key1">new</span> <span class="key5">Vector</span>&lt;Item&gt;();
   <span class="key1">for</span> (<span class="key5">Collection</span>&lt;Item&gt; c : collections) {
      <span class="key1">for</span> (Item i : c) {
         v.add(i);
      }
      doSomething(v);
      v.clear();
   }

</pre><p>
This is not by itself bad about Java but it shows a problem many don't
acknowledge: Even with a GC'd language, you need to take care of memory
allocations.</p>
<p>
Another issue with garbage collection is the non-determinism of your runtime.
There is no way to know when the garbage collector will next run. It may happen
during a speed-critical part of your application. Imagine running a game server.
When a player is switching maps, it is fine to free objects no longer used
because they were on the previous map. During a fight, however, it would be
rather annoying if the server paused due to a GC run. Because of this, I don't
consider GC'd languages to be real-world ready. At least, it is extremely
difficult to write real-time software.</p>
<p>
You can of course call <span class='code'>Runtime.getRuntime().gc()</span>, but this is entirely
non-deterministic, as well. The <span class='code'>gc()</span> call may or may not free memory. The
decision is still up to the collector.</p>
<p>
To be usable in real-time applications such as the described game server, being
able to suspend the GC temporarily in speed-critical moments would help.  Java
does not supply this kind of control over the GC. The D programming language
does and is therefore more usable for such applications.</p>
<p>
Also see the point on RAII later on why garbage collection is bad.</p>
</li>
<li>
Object orientation<a id='oop'></a><p>
A language like Java is supposed to propagate object-oriented design. What it
really does it make people think that when you write buzzwords like <span class='code'>class</span>,
<span class='code'>extends</span> and <span class='code'>new</span> or use a dot ('.') as method and field access operator,
you are writing object-oriented code. It is my strong opinion that all of these
do not have much to do with object-orientation.</p>
<p>
People seem to think that when a language such as Java enforces this kind of
object-orientation, the produced code is automatically object-oriented. They may
have forgot the keyword <span class='code'>static</span>.</p>
<p>
Why does Java have primitive types? For speed? What are optimisers for? If it
really wants to be so object-oriented, then why are <span class='code'>int</span>s no objects. Why
can't I do <span class='code'>i.toString()</span>? I have to do <span class='code'>Integer.valueOf(i).toString()</span> or
<span class='code'>Integer.toString(i)</span>. So much for consistency in the language. I thought
everything had a <span class='code'>toString()</span>. No, primitives don't.</p>
</li>
<li>
Slow<a id='slow'></a><p>
I once had a discussion with a Java advocate on Java's speed. He said, Java can
lock and unlock a mutex much faster than pthreads. Funny thing, since Java's
native threads implementation (hpi) on linux actually uses pthreads.  What he
meant was Java's green threads. Green threads, however, gain nothing but
asynchronic execution of code. They are comparable to coroutines and
continuations in Python or Perl.</p>
<p>
A few numbers from local tests with Sun's JDK 1.6.0_06:</p>
<ul>
<li>
A method call is 7 times slower than direct access.</li>
<li>
A <span class='code'>synchronized</span> call is 8 times slower than a normal method call.</li>
<li>
A <span class='code'>final</span> call is 10% faster than a normal method call.</li>
</ul>
<p>
Note that Java <a href='why-use_java.xhtml#jvm'>can be fast</a>.</p>
</li>
<li>
"Fail-Safe"<a id='failsafe'></a><p>
It is impossible to disable a method or code block by adding a <span class='code'>return</span> or
<span class='code'>continue</span> statement due to <em>14.21 Unreachable Statements</em>: "It is a
compile-time error if a statement cannot be executed because it is unreachable."</p>
<p>
On the other hand, Java is not fail-safe at all.</p>
<ul>
<li>
Floating point comparison<p>
The primitive types <span class='code'>float</span> and <span class='code'>double</span> have <span class='code'>operator==</span> defined but it is
entirely useless. Floating point numbers should never be compared using the
equality operator. Why does Java, the so-much-checked language allow this?</p>
</li>
<li>
No <span class='code'>const</span><p>
The lack of a <span class='code'>const</span> keyword in Java leaves many possiblities to error. While
Java is always trying to be as fail-safe as possible, it fails to prevent
modifying a value that is supposed to remain constant. The <span class='code'>final</span> keyword
works like the top-level <span class='code'>const</span> in C. A <span class='code'>final</span> method, however, has nothing
to do with constness. It means it can not be overridden (I consider this an
inconsistency). C can prevent a function from modifying its argument or a caller
from modifying a return value. C++ can prevent non-<span class='code'>const</span> member functions
from being called on a <span class='code'>const</span> object.</p>
<p class='small'>Note that "top-level" const in C means "Object* const x". The pointer itself can
not be modified, but the pointee (the object being pointed at) can.

</p><p class='small'>Also note that even though "final" is <em>like</em> "const", it is not exactly
the same. In Java, you can leave a final variable uninitialised on declaration
and assign it <em>once</em> later. For example, a static final field can be
assigned once in a static { } block but then it works like C's top-level const.

</p></li>
</ul>
<p>
Also, consider the following code snippet:</p>
<pre class="code-block">    <span class="key1">public</span> <span class="key3">static</span> <span class="key3">void</span> main (<span class="key5">String</span>[] argv) {
        <span class="key3">int</span> i;
        <span class="key1">if</span> (argv.<span class="key1">length</span> &gt;= <span class="number">0</span>) {
            i = <span class="number">5</span>;
        }
        <span class="key5">System</span>.out.println(i);
    }

</pre><p>
The compiler errors out, saying that i "may not have been initialised". Is that
so? Array lengths can never be less than 0. If our compiler is smart enough to
prevent compilation of this code, it should be smart enough to know that <span class='code'>i</span> is
actually always initialised. So, what we have to do is zero-initialise the
variable manually. That leads to another question: why are locals not
zero-initialised? Is that for speed? Class fields are zero-initialised. Why is
that? Isn't speed just as important there as it is with locals? I call that an
inconsistency, which leads us to the next point.</p>
<p class='small'>Admittedly, this is a rather useless condition for setting i, but there are
real-world examples where this imposes a really annoying issue. Java programmers
will know.

</p></li>
<li>
It compiles? Ship it!<p>
The above mentioned "fail-safety" makes programmers think that if their compiler
does not complain (and even Eclipse shuts up), their code is correct.  This may
be true from a syntax point of view, even some semantic checks may have been
performed, but the code may still not do what they expected. Even a seemingly
fail-safe language such as Java is not a mind-reader.</p>
</li>
<li>
Inconsistent<a id='inconsistent'></a><p>
Java has several inconsistencies in its design. Whether to call them
inconsistencies, inelegancies or features is up to the reader. I consider these
to be inconsistencies.</p>
<ul>
<li>
<span class='code'>synchronized</span> methods<p>
Java does not support multiple inheritance, because it is "bad". Java does not
support default method arguments because they are "bad". <span class='code'>synchronized</span> methods
are "bad", too, so why do they exist?</p>
</li>
<li>
Java Language Specification 4.3.1: "An object is a class instance or an array."<p>
Why are arrays objects? They have a <span class='code'>length</span> field and are passed by reference,
but they are not class instances. You can not inherit from arrays but you can
put them into a Collection. Array types are classes, arrays are instances of the
array type class. Why does 4.3.1 special-case the object definition?</p>
<p>
Note that arrays are indeed classes as can be seen from their <span class='code'>.getClass()</span>
method, which returns something like "[I" for <span class='code'>int[]</span>. They inherit directly
from <span class='code'>java.lang.Object</span> and implement <span class='code'>java.lang.Cloneable</span> and
<span class='code'>java.io.Serializable</span>.</p>
</li>
<li>
<span class='code'>finally</span> is always executed<p>
This is not inconsistent with the specification, but inconsistent with common
belief. The <span class='code'>finally</span> block is executed when the <span class='code'>try</span> block exits. This means
if it does not exit, for instance due to a call to <span class='code'>System.exit()</span>, <span class='code'>finally</span>
is not executed.</p>
</li>
<li>
Always use getters and setters<p>
Java wants data hiding by using getters and setters? The <span class='code'>java.awt.Point</span> class
allows direct access of the public fields <span class='code'>x</span> and <span class='code'>y</span>. Arrays have a <span class='code'>public
final int length</span> that can be directly accessed (but obviously not modified due
to it being final).</p>
</li>
<li>
No operator overloading<p>
..except for arrays, <span class='code'>String</span>. Arrays and <span class='code'>String</span> define <span class='code'>operator[]</span>.
<span class='code'>String</span> defines <span class='code'>operator+</span> and <span class='code'>operator+=</span>. <span class='code'>Long</span>, <span class='code'>Integer</span>, <span class='code'>Short</span>,
<span class='code'>Byte</span> and <span class='code'>Character</span> define all arithmetic operators except arithmetic
assignment (such as +=). In order to execute operators where one operand is of
primitive type, the class is unboxed, which means the value is extracted and
used as operand to the operation. This does not happen if both operands are of
class type. In other words, <span class='code'>Integer += int</span> works, <span class='code'>int += Integer</span> works but
<span class='code'>Integer += Integer</span> does not work. <span class='code'>Integer &lt; Integer</span>, however, works and
so do <span class='code'>Integer + Integer</span> and all other arithmetic operations. The <span class='code'>Boolean</span>
class overloads <span class='code'>operator!</span>.</p>
</li>
<li>
Unreachable code is not allowed (14.21)<p>
Except in <span class='code'>if (false) { }</span> statements, which is Java's attempt to emulate
compile-time conditionals such as the ones provided by a preprocessor. This
exception does not hold for <span class='code'>while (false) { }</span>.  Consider code like this:</p>
<pre class="code-block">   <span class="key1">while</span> (<span class="key4">true</span>) <span class="key1">return</span>;
   <span class="key5">System</span>.out.println(<span class="string">"Unreachable"</span>); <span class="comment">// this statement is unreachable and an error</span>
   <span class="comment">// but</span>
   <span class="key1">if</span> (<span class="key4">true</span>) <span class="key1">return</span>;
   <span class="key5">System</span>.out.println(<span class="string">"Unreachable"</span>); <span class="comment">// this statement is unreachable but not an error</span>

</pre><p>
Note that this behaviour is specified by the JLS. I do think, though, that this
is inconsistent.</p>
</li>
</ul>
</li>
<li>
No RAII possible<a id='raii'></a><p>
An important pattern in languages such as Perl and C++ is RAII, which stands for
"Resource Acquisition Is Initialisation". It basically means that objects
acquire resources in their constructor and release it in their destructor. A
good example of this is lock acquisition and release:</p>
<pre class="code-block">   <span class="key3">void</span> function (<span class="key3">int</span> i)
   {
     mutex::locker mlock (<span class="key1">this</span>-&gt;mtx);
     check (i);
     <span class="key1">this</span>-&gt;number += i;
   }

</pre><p>
This code locks a mutex and unlocks it whenever the function returns. This may
happen on exceptions or on normal return. The <span class='code'>check</span> function may throw an
exception if <span class='code'>i</span> is wrong. We don't have to care about that here. In Java, we
do:</p>
<pre class="code-block">  <span class="key3">void</span> function(<span class="key3">int</span> i) <span class="key1">throws</span> <span class="key5">Exception</span>
  {
      <span class="key1">this</span>.mtx.lock ();
      <span class="key1">try</span> {
          check(i);
      } <span class="key1">finally</span> {
          <span class="key1">this</span>.mtx.unlock();
      }
      <span class="key1">this</span>.number += i;
  }

</pre><p>
In the code above, the issue is not that apparent, but when you start playing
with file I/O, you may need a cascade of up to three <span class='code'>try</span>'s and <span class='code'>catch</span>es in
order to catch all exceptions thrown. Opening, writing and closing may throw. A
lot of typing work that could have been saved by RAII.</p>
</li>
<li>
No proper compiler diagnostics<a id='diag'></a><p>
The default Java compiler's diagnostics are pretty sparse. You have to ask for
specific warnings using -Xlint:(unchecked|path|serial|finally|fallthrough).
Even this set of additional warnings is not very complete. It does not, for
instance, warn about unused fields in a class. It does not warn about an enum
possibility not being cased in a switch. Even with the warnings on, it is often
unclear what exaclty needs to be done to fix the warning. "unchecked call to
add(E) as a member of the raw type java.util.ArrayList". If you want decent
diagnostics, you need to use something like the Eclipse compiler.</p>
</li>
<li>
Almost enforced writing of documentation<a id='javadoc'></a><p>
This may by itself not sound bad, but it leads to comments such as these:</p>
<pre class="code-block">   <span class="comment">/**
    * Returns the X coordinate of this &lt;code&gt;Point2D&lt;/code&gt; in
    * &lt;code&gt;double&lt;/code&gt; precision.
    * @return the X coordinate of this &lt;code&gt;Point2D&lt;/code&gt;.
    * @since 1.2
    */</span>
   <span class="key1">public</span> <span class="key3">abstract</span> <span class="key3">double</span> getX();

</pre><p>
Breaking up the description:</p>
<ul>
<li>
It returns the X coordinate<p>
Who would have thought that? Saying that <span class='code'>getX()</span> returns the X coordinate is
really enlightening, isn't it?</p>
</li>
<li>
The X coordinate it returns belongs to the class <span class='code'>Point2D</span><p>
Right, the fact that we are looking at the documentation of <span class='code'>Point2D</span> might
have been ignored or we could have missed that when searching for the
documentation.</p>
</li>
<li>
It returns those in <span class='code'>double</span> precision<p>
Is this for people who don't see the <span class='code'>double</span> part of the method signature?</p>
</li>
<li>
It returns the X coordinate of this <span class='code'>Point2D</span><p>
Oh, really?</p>
</li>
<li>
The method exists since Java 1.2<p>
Okay, that's fair, it means I can't use it with a pre-1.2 Java compiler and
development kit.</p>
</li>
</ul>
<p>
Enforced documentation writing leads to a lot of text saying next to nothing.
The only piece of information that might be of value to us is the @since
directive. The rest is 100% redundant. Why didn't they say it was <span class='code'>abstract</span>?
That's <em>really</em> important, since we can't read method signatures, right?</p>
</li>
<li>
"Write once, run everywhere"<a id='wore'></a><p>
This is not true at all, especially when using JNI. Even without JNI, Java code
behaves differently on different platforms. Most notably is the GUI with AWT
where closing a window on Linux needs different code than for Windows.  Right
clicking elements in a Swing GUI also behaves differently on Linux than on
Windows.</p>
</li>
<li>
No auto-expanding heap<a id='heap'></a><p>
Unlike applications on POSIX systems (and possibly on Windows, as well), the
amount of memory granted to the application is limited and not auto-expanding.
This may not be a bad idea for server applications where memory has to be shared
by multiple processes, but when using the Eclipse platform with certain plugins,
you need to manually raise the maximum amount of memory granted using the
<span class='code'>-Xmx</span> option.</p>
<p>
In theory, the application may never require more than the default 256MB of
heap, but due to Java being a garbage collected language, it often does.</p>
<p class='small'>Note: starting with Sun HotSpot Java 1.4, it is possible to enabled
auto-expanding heap using the <span class="code">-XX:+AggressiveHeap</span>
option on startup.

</p></li>
<li>
No "rethrow"<a id='rethrow'></a><p>
In Java, it is not possible to throw the same exception, preserving the stack
trace. In C++, we could do:</p>
<pre class="code-block">   <span class="key1">try</span> {
     function ();
   } <span class="key1">catch</span> (exception <span class="key3">const</span> &amp;e) {
     do_some_cleanups ();
     <span class="key1">throw</span>;
   }

</pre><p>
In Java, we have to create a new <span class='code'>Exception</span> object and pass the old one as
argument:</p>
<pre class="code-block">   <span class="key1">try</span> {
       method();
   } <span class="key1">catch</span> (<span class="key5">Exception</span> e) {
       doSomeCleanups();
       <span class="key1">throw</span> <span class="key1">new</span> <span class="key5">Exception</span>(e);
   }

</pre></li>
<li>
Everything passed by value<a id='pass_by_value'></a><p>
This means you cannot pass an <span class='code'>int</span> and expect it to be modified. Neither can
you pass a reference to an object and expect it to be modified. Returning an
object is in fact returning a reference to this object by value. This means it
is impossible to write an overloaded <span class='code'>increment</span> method that takes an argument
and increments it. You can of course work around this by letting the increment
function return the value incremented. This, however, creates a new object each
time, making it unfeasible to use.</p>
</li>
<li>
Backwards compatibility limits innovation<a id='compat'></a><p>
Due to the fact that Java needs to be binary compatible with at least JDK 1.1.x,
new technologies are often braked down. Generics cannot be properly implemented
the way they are in .NET. Generics need to be implemented with type erasure in
order to preserve backwards compatibility. The reflection API must remain
compatible with 1.1.x. Classes from Java 1.4 need to be able to load classes
from Java 7.</p>
</li>
<li>
<span class='code'>javac</span> optimises poorly<a id='opt'></a><p>
The Java compiler has a very poor optimiser. It leaves all heavy optimisation to
the runtime environment, which does peep-hole optimisation on bytecode and code
inlining.</p>
</li>
<li>
Programcode is not a data structure<a id='codestruct'></a><p>
In Java, it is not possible to modify the code on the fly, for example by
changing the AST at runtime as it is possible in languages such as Lisp. This is
a problem with many curly-bracket languages.</p>
</li>
</ul>
<h3>
<a id='h1'>Links</a></h3>
<ul>
<li>
<a href='http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html'>The Perils of JavaSchools</a></li>
<li>
<a href='http://www.cs.arizona.edu/projects/sumatra/hallofshame/'>The Java Hall of Shame</a></li>
<li>
<a href='http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html'>The Java Language Specification, Third Edition</a></li>
</ul>

		</div> 

		<div id="footer"> 
			<div id="copyright"><a href="/~pippijn/home/contact">Copyright &copy; 2007-2011 Pippijn van Steenhoven</a></div> 
			<div id="updated">Last updated Fri May 27 22:07:44 MEST 2011</div> 
		</div> 
	</body> 
</html> 

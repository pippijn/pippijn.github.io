<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"> 
	<head> 
		<title>Pippijn - Projects / Devel / Makepp / Rules</title> 
		<meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/> 
		<meta http-equiv="content-style-type" content="text/css"/> 
		<meta name="description" content="Pippijn van Steenhoven - Projects / Devel / Makepp / Rules"/> 
		<link rel="stylesheet" href="/home/css/home.css" type="text/css" title="Clean Blue" media="screen"/> 
		<link rel="icon" type="image/x-icon" href="/home/favicon.ico"/>
	</head> 

	<body> 
		<div id="header"> 
			<h1>Pippijn van Steenhoven</h1> 
			<p id="slogan">I doubt, therefore I might be</p> 
		</div> 

		<div id="sidebar"> 
			<h2>Menu</h2> 
			<div id="menubar">
				<ul>
<li>
<a href="/home/">Home</a></li><li>
<a href="/home/projects">Projects <span class="small">[-]</span></a><ul>
<li>
<a href="/home/projects/devel">Developer tools <span class="small">[-]</span></a><ul>
<li>
<a href="/home/projects/devel/autoproj">Autoproj</a></li><li>
<a href="/home/projects/devel/clangide">Clang IDE</a></li><li>
<a href="/home/projects/devel/libcommon">libcommon</a></li><li>
<a href="/home/projects/devel/makepp">Autocomb <span class="small">[-]</span></a><ul>
<li>
<a href="/home/projects/devel/makepp/project">Project</a></li><li>
<a href="/home/projects/devel/makepp/variables">Variables</a></li><li>
<a href="/home/projects/devel/makepp/target">Targets</a></li><li>
<a href="/home/projects/devel/makepp/template">Templates</a></li><li>
<a id="actmenu">Rules</a></li><li>
<a href="/home/projects/devel/makepp/examples">Examples</a></li></ul></li></ul></li><li>
<a href="/home/projects/edu">Education <span class="small">[+]</span></a></li><li>
<a href="/home/projects/games">Games <span class="small">[+]</span></a></li><li>
<a href="/home/projects/net">Network <span class="small">[+]</span></a></li><li>
<a href="/home/projects/lang">Languages <span class="small">[+]</span></a></li><li>
<a href="/home/projects/robotics">Robotics <span class="small">[+]</span></a></li><li>
<a href="/home/projects/system">Systems <span class="small">[+]</span></a></li></ul></li><li>
<a href="/home/programming">Programming <span class="small">[+]</span></a></li><li>
<a href="/home/links">Links</a></li><li>
<a href="/home/contact">Contact</a></li></ul>
			</div> 
		</div> 

		<div id="content">
			<h2>
Rules</h2>
<ul><li><a href='#h1'>Pattern matching</a></li>
<li><a href='#h2'>Code continuations</a></li>
<li><a href='#h3'>Special variables in rules</a></li>
<li><a href='#h4'>Target-specific variables</a></li>
<li><a href='#h5'>Output in $(builddir)</a></li>
<li><a href='#h6'>Silencing rules</a></li>
<li><a href='#h7'>External rules</a></li>
<li><a href='#h8'>Replacing automake rules</a></li></ul><p>
<span class='code'>Autocomb</span> defines a few rules itself and has knowledge about automake-defined
rules, so that e.g. rules for compiling C sources are not emitted again. The
rules feature in <span class='code'>Autocomb</span> is the reason this project was actually started. The
syntax is basically the same as GNU Make pattern rules with some extensions, but
the way they are expanded makes them much more useful.</p>
<pre class="code-block">   %.o: %.c {
      <span class="key2">$(CC)</span> <span class="key2">$&lt;</span> -o <span class="key2">$@</span>
   }

</pre><p>
The above example is a simple rule to build object files from C sources. The
rule is instantiated for each match, so that the resulting Makefile has only
explicit rules.</p>
<p>
Rules are matched on the graph, rather than on the file system. When a rule
matches a file in the graph, an edge from that file to the new file is created.
Other rules can then match this new file.</p>
<p>
Rules defined in a program block implicitly depend on that program and
<span class='code'>$(THIS)</span> expands to the program location with <span class='code'>$(EXEEXT)</span> appended. Thus, in
this case, the <span class='code'>$(THIS)</span> variable used in rules is expanded to
<span class='code'>$(builddir)/msgcat$(EXEEXT)</span></p>
<pre class="code-block">   <span class="key1">program</span> msgcat {
      %.c: %.msg {
         <span class="key2">$(THIS)</span> -c <span class="key2">$&lt;</span> <span class="key2">$@</span>
      }
   }

</pre><p>
Rules inside programs are always considered for match, but are disabled in the
resulting Makefile, if the program was conditional and disabled at configure
time.</p>
<h3>
<a id='h1'>Pattern matching</a></h3>
<p>
The introductory example is already a pattern rule. Patterns in <span class='code'>Autocomb</span> are
slightly more advanced than in GNU Make. There is a set of rules defining which
pattern is matched. Simply speaking, the most special pattern is matched.</p>
<pre class="code-block">   %.c: %.y {
      ...
   }
   src/%.c: src/%.y {
      ...
   }

</pre><p>
In the above example, the second rule is matched for all <span class='code'>.y</span> files under
<span class='code'>src/</span>. All other <span class='code'>.y</span> files are matched by the first rule.</p>
<h3>
<a id='h2'>Code continuations</a></h3>
<p>
Rules can span multiple lines, just like <a href='variables'>variables</a>.</p>
<pre class="code-block">   %.c: %.y {
      echo This is the first line
      bison
         -y
         -o <span class="key2">$@</span>
         <span class="key2">$&lt;</span>
      echo This is
         the third line
   }

</pre><h3>
<a id='h3'>Special variables in rules</a></h3>
<ul>
<li>
$<<p>
This variable expands to the first dependency. It does not exist, if the target
does not have any dependencies or the only dependency is <span class='code'>$(THIS)</span>.</p>
</li>
<li>
$@<p>
This variable expands to the target. It does not exist, if the rule has multiple
targets.</p>
</li>
<li>
$*<p>
The string matched by <span class='code'>%</span> in a pattern rule. It only exists in pattern rules.</p>
</li>
<li>
$1 ... $n<p>
The <span class='code'>n</span>th dependency. Only dependencies listed on the rule itself are
considered. Dependencies in external dependency declarations are not considered.</p>
</li>
<li>
$-1 ... $-n<p>
The <span class='code'>n</span>th dependency, counting from the last. Thus, <span class='code'>$-1</span> is the last
dependency.</p>
</li>
<li>
$0<p>
An alias for <span class='code'>$(THIS)</span>. Neither <span class='code'>$0</span> nor <span class='code'>$(THIS)</span> exist in global rules.</p>
</li>
</ul>
<h3>
<a id='h4'>Target-specific variables</a></h3>
<p>
For a generic rule, it is often useful to let targets define an additional set
of flags for the tool. The variable syntax <span class='code'>$[VAR]</span> roughly expands to
<span class='code'>$(AM_VAR) $(VAR) $($(target)_VAR)</span>, where <span class='code'>$(target)</span> is the <span class='code'>program</span> or
<span class='code'>library</span> the target file is being built for.</p>
<pre class="code-block">   %.c: %.y {
      <span class="key2">$(YACC)</span> <span class="key2">$[YFLAGS]</span> -o <span class="key2">$@</span> <span class="key2">$&lt;</span>
   }

   <span class="key1">program</span> myparser {
      <span class="key1">sources</span> {
         src/parser.y
      }
   }

</pre><p>
The pattern rule in the above example might be expanded to roughly the following
make code:</p>
<pre class="code-block">   src/parser.c: src/parser.y
      <span class="key2">$(MKDIR_P)</span> src/
      <span class="key2">$(YACC)</span> <span class="key2">$(AM_YFLAGS)</span> <span class="key2">$(YFLAGS)</span> <span class="key2">$(myparser_YFLAGS)</span> -o src/parser.c \
         `test -f <span class="string">'src/parser.y'</span> || echo <span class="string">'$(srcdir)/'</span>`src/parser.y

</pre><p>
The <span class='code'>test</span> makes sure that vpath builds work correctly. The first line will
make the target directory, if it does not yet exist.</p>
<h4>
$(TARGET)</h4>
<p>
The special variable <span class='code'>$(TARGET)</span> will expand to the library or program name.
Not only that, but you can also access its declarations using the syntax
described in <a href='variables'>variables</a>.</p>
<pre class="code-block">   %.c: %.cx {
      <span class="key2">$(CPP)</span>
         -DTARGET=<span class="string">'"$(TARGET)"'</span>
         -DLIBRARIES=<span class="string">'"$(TARGET.link : library)"'</span>
         <span class="key2">$&lt;</span> -o <span class="key2">$@</span>
   }

   <span class="key1">program</span> myprog {
      <span class="key1">sources</span> {
         main.cx
      }
      <span class="key1">link</span> {
         mylib1
         -lm
      }
   }

</pre><p>
In the above example, <span class='code'>$(TARGET.link : library)</span> will be expanded to <span class='code'>mylib1</span>.</p>
<h3>
<a id='h5'>Output in $(builddir)</a></h3>
<p>
You may want to output the resulting files directly into the <span class='code'>$(builddir)</span>,
instead of a subdirectory. For this use case, the <span class='code'>%%</span> pattern may be used.</p>
<pre class="code-block">   %%.c: %%.y {
      <span class="key2">$(YACC)</span> <span class="key2">$[YFLAGS]</span> -o <span class="key2">$@</span> <span class="key2">$&lt;</span>
   }

</pre><p>
The <span class='code'>%%</span> pattern on the left will match exactly one path segment, i.e. without
any path separators (<span class='code'>/</span>). A <span class='code'>%%</span> on the right matches any number of path
segments before matching the final path segment, i.e. the file, which was
matched by the <span class='code'>%%</span> on the left. The above example might be expanded to:</p>
<pre class="code-block">   parser.c: src/parser.y
      <span class="key2">$(YACC)</span> <span class="key2">$(AM_YFLAGS)</span> <span class="key2">$(YFLAGS)</span> <span class="key2">$(myparser_YFLAGS)</span> -o parser.c \
         `test -f <span class="string">'src/parser.y'</span> || echo <span class="string">'$(srcdir)/'</span>`src/parser.y

</pre><p>
As you can see, a <span class='code'>mkdir</span> is no longer necessary and the output is now in the
current directory.</p>
<h3>
<a id='h6'>Silencing rules</a></h3>
<p>
Similar to <span class='code'>make</span>, lines of a recipe may be silenced by prepending them with
<span class='code'>@</span>. <span class='code'>Autocomb</span> extends this to automake <span class='code'>silent-rules</span>.</p>
<pre class="code-block">   %.c: %.y {
      @echo Calling bison
      @(YACC)bison <span class="key2">$&lt;</span> -o <span class="key2">$@</span>
   }

</pre><p>
The <span class='code'>@(NAME)</span> syntax emits an <span class='code'>$(AM_V_GEN)</span>-like variable that prints <span class='code'>YACC</span>
and the target (<span class='code'>$@</span>) in the <span class='code'>silent-rules</span> style. Calling <span class='code'>make V=1</span> will
print the actual command instead of the single-line message.</p>
<h3>
<a id='h7'>External rules</a></h3>
<p>
If <span class='code'>Autocomb</span> is not flexible enough for the use case, external rules may be
imported using the <span class='code'>extern</span> keyword. You may optionally add rule stubs
declaring patterns or explicit graph edges that may be assumed as being
implemented. Note that these rules are not special and more exact rules can
still be matched.</p>
<pre class="code-block">   <span class="key1">extern</span> <span class="string">'lex-rules.am'</span> %.c: %.l
   <span class="key1">extern</span> <span class="string">'yacc-rules.am'</span> {
      %.c: %.y ;
      %.h: %.y ;
   }
   <span class="key1">extern</span> <span class="string">'more-rules.am'</span>

</pre><h3>
<a id='h8'>Replacing automake rules</a></h3>
<p>
The power gained with the introduction of these pattern rules can be used to
replace large parts of automake. E.g. a simplified automake rule for building
object files from C sources can be written as follows:</p>
<pre class="code-block">   %%.o: %%.c {
      <span class="key2">@(CC)$(CC)</span> <span class="key2">$[CPPFLAGS]</span> <span class="key2">$[CFLAGS]</span> -MT <span class="key2">$@</span> -MD -MP -MF <span class="key2">$(DEPDIR)</span>/<span class="key2">$*.Tpo</span> -c -o <span class="key2">$@</span> <span class="key2">$&lt;</span>
   }

</pre><p>
Automake still provides many useful tools, such as its <span class='code'>distcheck</span> and
<span class='code'>parallel-tests</span> facilities. These tools are the reason <span class='code'>Autocomb</span> targets automake
and not make, directly.</p>
<p>
Also note that it's not useful to actually rewrite the automake rules, as the
resulting Makefile will not be any shorter. Automake may do optimisations at a
lower level than <span class='code'>Autocomb</span>, so it is not advisable to override many of its rules.</p>

		</div> 

		<div id="footer"> 
			<div id="copyright"><a href="/home/contact">Copyright &copy; 2007-2013 Pippijn van Steenhoven</a></div> 
			<div id="updated">Last updated Mon Jul 18 01:16:23 MEST 2011</div> 
		</div> 
	</body> 
</html> 
